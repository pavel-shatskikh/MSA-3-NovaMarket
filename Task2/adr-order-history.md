# ADR: История покупок

**Название задачи:** Просмотр истории покупок (Order History)  
**Автор:** Pavel Shatskikh
**Дата:** 2025-08-18

---

## Функциональные требования

| № | Акторы                 | Use Case       | Описание                                                                                                                |
|:-:|------------------------|----------------|-------------------------------------------------------------------------------------------------------------------------|
| 1 | Пользователь           | Список заказов | Получить список всех заказов пользователя с датой, суммой, способом доставки, финальным статусом. Пагинация/сортировка. |
| 2 | Пользователь           | Детали заказа  | Получить товары, количество, цены по позициям, итог, способ оплаты/доставки, финальный статус.                          |
| 3 | Пользователь → Invoice | Скачать чек    | В деталях заказа получить pre‑signed URL на PDF и скачать его из S3.                                                    |
| 4 | Пользователь → Review  | Оставить отзыв | Создать/обновить отзыв для товара из заказа.                                                                            |
| 5 | Пользователь → Cart    | Заказать снова | Добавить все позиции прошлого заказа в корзину пользователя.                                                            |

## Нефункциональные требования

| № | Требование                                                                                                                                 |
|:-:|--------------------------------------------------------------------------------------------------------------------------------------------|
| 1 | p95: список ≤ 300 мс, детали ≤ 400 мс при прогретом read‑store (для учета требований к отклику интерфейса)                                 |
| 2 | Eventual consistency: свежесть проекций ≤ 5 с (ничего страшного если данные по заказам будут появляться с не большой задержкой в истории). |
| 3 | Доступность чтений 99.9%. Грейсфул‑деградация при недоступности Review/Cart/Invoice.                                                       |
| 4 | Безопасность: доступ к чужим данным исключён (JWT, проверка заказов по user_id).                                                           |
| 5 | Наблюдаемость: метрики, структурированное логирование, трассировка (traceId/spanId).                                                       |

## Решение

Использовать паттерн CQRS + API Composition (для получения деталей):

- вводится отдельный сервис Order History Query Service, который хранит модель для чтения данных в ленте истории
  покупок;
- формат данных адаптирован для модели чтения и содержит базовый набор полей, необходимых для отображения в ленте
  истории покупок;
- модели записи хранится в отдельном сервисе Order Service (как это было в прошлой задаче) и работает точно также через
  события;
- если пользователь хочет получить какую-то дополнительную информацию по заказу, то используется паттерн API
  Composition;
- в этом случае Order History Query Service обращается к смежным сервисам (например Review Service, чтобы оставить отзыв
  на товар из истории);

**Компоненты C2:**

- **API Gateway → BFF (Mobile)** — фронтовой API, авторизация (JWT), кэширование ответов, пагинация.
- **Order History Query Service + Read Store (PostgreSQL)** — единая точка чтения списка и деталей
  заказов. Хранит денормализованный снимок заказа на момент покупки (название товара, цена,
  изображение, суммы, статусы, способы доставки/оплаты).
- **Kafka** — шина событий. Источники: **Order**, **Payment**, **Delivery** публикуют доменные события через
  Outbox+CDC. Query‑сервис потребляет их и обновляет read‑модель (идемпотентно).
- **Invoice Service + S3** — выдаёт pre‑signed URL для PDF чека.
- **Review Service** — создание/просмотр отзывов.
- **Cart Service** — заказать снова.
- **Auth Service** — проверка JWT в BFF/Query сервисе.

## Обоснование

- основной экран и детали читаются из одного сервиса с адаптированной моделью и соблюдением всех нефункциональных
  требований;
- статусы/итоги заказа формируются через события Kafka из разных доменов (Order/Payment/Delivery);
- действия «чек/отзыв/...» — отдельные синхронные вызовы, не ломают производительность, так как обращений будет
  значительно меньше чем к самой истории;

## Рассмотренные альтернативы

1) **API Composition (без read‑модели)**  
   Плюсы: быстро стартовать, нет дублирования.  
   Минусы: сложная композиция запросов для объединения данных, дополнительная нагрузка на существующие сервисы, сложно
   расширять, сильная связанность, можем не уложиться в нефунциональные требования.

2) **Event Sourcing**  
   Плюсы: полная история изменений по каждому заказу.  
   Минусы: сложнее в реализации, нужно строить отдельные модели для чтения по событиям, кажется что для данной задачи
   избыточно.

## Риски и ограничения

- Eventual consistency: задержка появления/обновления заказа до 1–5 с (если это критично для бизнеса).
- Поддержка схем событий и версионирование (сложнее разработка).
- Дублирование данных в read‑модели (больше ресурсов на поддержку).
